<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: testing, | ædʒirei]]></title>
  <link href="http://pzol.github.com/pzol/blog/categories/testing-/atom.xml" rel="self"/>
  <link href="http://pzol.github.com/pzol/"/>
  <updated>2012-02-26T07:34:13+01:00</updated>
  <id>http://pzol.github.com/pzol/</id>
  <author>
    <name><![CDATA[Piotr Zolnierek]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OOP Acceptance Tests - Cucumber]]></title>
    <link href="http://pzol.github.com/pzol/blog/2012/03/01/object-oriented-acceptance-tests-cucumber/"/>
    <updated>2012-03-01T09:59:00+01:00</updated>
    <id>http://pzol.github.com/pzol/blog/2012/03/01/object-oriented-acceptance-tests-cucumber</id>
    <content type="html"><![CDATA[<h2>Example in Cucumber</h2>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (find_slow_transactions.feature)</span> <a href='/downloads/code/executable-documentation/find_slow_transactions.feature'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='gherkin'><span class='line'><span class="k">Feature:</span><span class="nf">  Find slow transactions</span>
</span><span class='line'><span class="nf">          User wants to find slow transactions</span>
</span><span class='line'><span class="nf">          So that he can optimize the system</span>
</span><span class='line'><span class="nf">          by identifying the transaction which take the most time</span>
</span><span class='line'>
</span><span class='line'><span class="nf">  </span><span class="k">Scenario:</span><span class="nf"> Find slow transactions (sunny day)</span>
</span><span class='line'><span class="k">    Given </span><span class="nf">the user is on the latest transactions page</span>
</span><span class='line'><span class="nf">    </span><span class="k">When </span><span class="nf"> the user searches by time_taken with &quot;</span><span class="s">20000</span><span class="nf">&quot;</span>
</span><span class='line'><span class="nf">    </span><span class="k">Then </span><span class="nf"> the user sees a list of transactions with response time longer than &quot;</span><span class="s">20000</span><span class="nf">&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="nf">  </span><span class="k">Scenario:</span><span class="nf"> Invalid </span>
</span><span class='line'><span class="k">    Given </span><span class="nf">the user is on the latest transactions page</span>
</span><span class='line'><span class="nf">    </span><span class="k">When </span><span class="nf"> the user searches by time_taken with &quot;</span><span class="s">invalid numeric</span><span class="nf">&quot;</span>
</span><span class='line'><span class="nf">    </span><span class="k">Then </span><span class="nf"> the user sees the latest transactions page</span>
</span><span class='line'><span class="nf">    </span><span class="k">And </span><span class="nf">  the uses sees an error notice saying &quot;</span><span class="s">Invalid time taken entered</span><span class="nf">&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OOP Acceptance Tests - Rspec]]></title>
    <link href="http://pzol.github.com/pzol/blog/2012/02/02/object-oriented-acceptance-tests/"/>
    <updated>2012-02-02T11:11:00+01:00</updated>
    <id>http://pzol.github.com/pzol/blog/2012/02/02/object-oriented-acceptance-tests</id>
    <content type="html"><![CDATA[<p>This is part two of my blog post about Acceptance Testing. In the previous post I outlined some basics, now let's get into the code.</p>

<h2>A real life example</h2>

<p>The tests I will be showing you are based on a real-life example, which I have (vastly) simplified for this article. Here is a picture how it looks like:</p>

<p><img src="/downloads/transaction_browser.png"></p>

<p>The source code for the test application is available at <a href="https://github.com/pzol/acceptance_testing">https://github.com/pzol/acceptance_testing</a></p>

<h2>Know your tools</h2>

<p>If you want to dive deep into acceptance testing, you can skip this part.</p>

<p><span class='pullquote-right' data-pullquote='automates fast feedback from the first minute '>
In order to be productive and not waste time with repeating tasks, I find it very important to setup an environment which automates fast feedback from the first minute about what is going on in your application and your tests.
</span></p>

<p>The tools I use here are</p>

<ul>
<li><a href="https://www.relishapp.com/rspec">Rspec</a></li>
<li><a href="https://github.com/guard/guard">Guard</a> - for running specs as they change</li>
<li><a href="https://github.com/jnicklas/capybara">Capybara</a> - to help testing the web application</li>
</ul>


<p>This is how my <code>.rspec</code> looks like:</p>

<pre><code>--color
--format progress
--fail-fast
</code></pre>

<p>This will format the output in color, display the output in dots (progress) format and most importantly turn on fail-fast, which will stop the tests at the first error!</p>

<p>For running single tests via Guard, I can override this options in the Guardfile</p>

<p><code>ruby Guardfile
guard 'rspec', :version =&gt; 2, :cli =&gt; "--format nested", :notification =&gt; true do
  watch(%r{^spec/.+_spec\.rb$})
end
</code></p>

<p>You can run the application under test using  <code>bundle exec rackup</code><br/>
then go with your browser to <code>http://localhost:9292</code></p>

<h2>Test Data</h2>

<p>As the system shall test the application end-to-end we need some test data, I have actually exported from a real database and saved as json</p>

<h2>My ideal acceptance test</h2>

<p>This is how I imagine an <em>acceptance test</em>:</p>

<p>```ruby sunny_day.rb
scenario 'latest transactions' do
  user = TestUser.new.extend(Role::TransactionsBrowser)
  user.visit_latest_transactions
  user.sees_transactions_table!</p>

<p>  user.sees_transactions_table!
  user.all_table_rows do |tr|</p>

<pre><code>tr.timestamp.should be_a DateTime 
</code></pre>

<p>  end
end<br/>
```</p>

<p>Although I generally recommend not to clutter your scenario with shoulds or asserts, sometimes having them means is faster and means much less code. Not having them adds the minor benefit, that you are not depending on a particular testing framework.</p>

<h2>The TestUser class</h2>

<p>It represents the Data in DCI. For the RSpec I create an empty class and add the <code>Capybara::DSL</code> as well as the <code>Capybara::RSpecMatchers</code>. Those will make available all the nice Capybara and RSpec matchers within the <code>TestUser</code> class and also to its instances.</p>

<p><code>ruby test_user.rb
class TestUser
  include RSpec::Matchers
  include Capybara::DSL
  include Capybara::RSpecMatchers
  include Role::Navigator
  include Role::Verifier
end
</code></p>

<h2>The TransactionBrowser Role</h2>

<p>It contains all the role methods which a person browsing the transactions might do. <br/>
The transactions page contains a list of transactions which have been sent to some API.</p>

<p>By calling <code>user.sees_transactions_table!</code> I define that the user sees the table. We intuitively know what it means to see that table and if it is alright. So mapping this to my mental model I only have this terse command with the bang! at the end, which means this is an <em>assertion</em>.  Inside this method I describe what it means, that the table is displayed correctly.</p>

<p>```ruby
def sees_transactions_table!
  headers = %w[timestamp contract facility method time_taken product]
  begin</p>

<pre><code>thead = find('#transactionsTable thead') 
</code></pre>

<p>  rescue Capybara::ElementNotFound</p>

<pre><code>raise("Could not find the transactionsTable in #{find('#summary').text}")
</code></pre>

<p>  end</p>

<p>  headers.each { |h| thead.should have_content h }
  table_rows.should have(20).rows
end
```</p>

<p>What is very important here, that we verify, that we have the correct page loaded and if not to display the error message in the test results, otherwise you will be doing a lot of 'puts-driven-development'.</p>

<p>I know that Sinatra displays its error in the <code>#summary</code> div, so I pick just this to be shown in my test results, Capybara nicely strips all the html around, so it is very readable in the console:</p>

<p>```
Could not find the transactionsTable in</p>

<pre><code>   NoMethodError at /

   undefined method `&lt;&lt;' for nil:NilClass
   file: 
       latest_transactions_context.rb
     location: block in call

     line:
        6
</code></pre>

<p>```</p>

<p>Next I verify all the table rows:</p>

<p><code>ruby
user.all_table_rows do |tr|
  tr.timestamp.should be_a DateTime
  tr.contract.should == 'test'
  tr.facility.should == 'api.test'
  tr.method.should == 'hotels'
  tr.time_taken.should be_a Fixnum
  tr.product.should == 'HOTEL'
end
</code></p>

<p>Ok, now that we are done with the basic sunny day scenario, we need the user to be able to search. Writing the scenario first.</p>

<p>```ruby
  scenario 'search by time_taken' do</p>

<pre><code>user.extend(Role::TimeTakenSearcher)
user.visit_latest_transactions
user.sees_transactions_table!

user.searches_for_time_taken(time_taken = 20000)

user.sees_transactions_table!

user.all_table_rows do |tr|
  tr.time_taken.should &gt; time_taken
end
</code></pre>

<p>  end
```</p>

<p>I can reuse easily the a lot of the code I used earlier. The new thing here is <code>user.searches_for_time_taken(time_taken = 20000)</code>. This will hide the ugly details of filling boxes and clicking, and is so much more readable.<br/>
I consciously am <strong>not</strong> checking for the count of rows as in the first example. I am verifying only what makes this scenario successful, which is the time_taken. This makes the tests also less brittle in case I decide to change the underlying test data later.</p>

<p>I introduce a new role <code>Role::TimeTakenSearcher</code>.</p>

<p>```ruby
module Role
  module TimeTakenSearcher</p>

<pre><code>def searches_for_time_taken(time_taken)
  fill_in 'time_taken', :with =&gt; time_taken
  click_button'searchButton'
end
</code></pre>

<p>  end
end
```</p>

<h2>Browser-less web-development promotes reliable acceptance tests</h2>

<p>While writing the accompanying application for this article, I decided <strong>not</strong> to open the browser, especially when errors occurred. It was difficult at first, but in the end it saved me a lot of time and it made my tests so much more reliable. It forced me to have more descriptive error messages.</p>

<h2>A word about test-speed</h2>

<p>I am a fan of <a href="https://github.com/guard/guard">Guard</a>, every time I save it runs the test I am working on in the background and notifies me by Growl if the test passed or not. Thus fast feedback is important for my workflow.</p>

<p>A single test should run fast, always, by that I mean less than 500 ms. On top of that comes the startup time. For Sinatra and Padrino that's usually 2-3 secs, for Rails... well... you might want to use Spork there.</p>

<p>That's another reason why you should have an object oriented design in your code, so you can use regular unit tests</p>

<p>Please do include unit test. Acceptance test show you if the system as a whole is working, but as they see it only from the user's point of view, they may not show you where the system is broken.</p>

<h2>Remember the rules</h2>

<p>When I write a new page, I start with the <strong>outside-inside</strong> principle (or also called feature injection) and <strong>TDD</strong>. I create a test, describing what I expect the page to look like. Then I write the view in html or haml to make the test pass. Only then start replacing the mockup of the page with logic!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OOP Acceptance Tests - Basics]]></title>
    <link href="http://pzol.github.com/pzol/blog/2012/01/29/object-oriented-acceptance-tests-basics/"/>
    <updated>2012-01-29T09:59:00+01:00</updated>
    <id>http://pzol.github.com/pzol/blog/2012/01/29/object-oriented-acceptance-tests-basics</id>
    <content type="html"><![CDATA[<p>I have had a very hard time to understand <em>how</em> and <em>why</em> to do acceptance testing. I was amazed by executable documentation, from the moment I heard the word. It bears the promise of a lean documentation. A documentation which is part of the actual software being built.</p>

<p>For me living documentation is a way to describe, thus define or in other words specify a system.</p>

<!-- find a better word for system -->


<p>This will be a series of short articles. The first one will be about the theory. The second will start with real code.</p>

<h2>User Stories and Use Cases</h2>

<p><span class='pullquote-right' data-pullquote='who? what? why? '>
User stories should be written so that they express what the user actually expects.<br/>
They are about describing what it looks like from the point of view of an actor being part of a narrative.
Stories answer the very important questions who? what? why?. The last-mentioned is actually the most important one.</p>

<p></span></p>

<p><span class='pullquote-right' data-pullquote='how? what? '>
Use cases are very important, too. They describe the same thing, but from a different perspective.
Use cases tell us more about how? what?
</span></p>

<h2>Context - Action - Outcome</h2>

<p>Given - When - Then</p>

<p>When setting up a context - verify it has been really setup, this is really important as you will know you are starting from the right spot, it will tell you early, that something is wrong with your environment, and not yet in the action or the outcome.</p>

<h2>Types of Tests</h2>

<p>Acceptance
: Does the whole system work?</p>

<p>Integration
: Does our code work against the code we can't change?</p>

<p>Unit
: Do our objects do the right thing, are they convenient to work with?</p>

<h2>Elements of acceptance tests</h2>

<ul>
<li>should exercise the system end-to-end</li>
<li>should see the system as it is seen by the user</li>
<li>should provide a documentation for later</li>
<li>should be coded in a clean way</li>
</ul>


<h2>Start on a Sunny Day</h2>

<p>Write your first scenario, you can name it 'Sunny Day' at first, so you don't have to think about the name to much. As soon as you work on it and realize a better name, change it accordingly.</p>

<h2>Then go into the Deviations</h2>

<h2>User Intentions vs System Responsibility</h2>

<h2>Staying Productive</h2>

<p>This is maybe a little off-topic, but maybe you find it useful.</p>

<p>While writing this project I used <strong>OmniFocus</strong> to keep a backlog of things to do. Every time something I wanted or needed to do crossed my mind, I put it on the list.
<strong>Vitamin-R</strong> and <strong>Pomodoro</strong> helped me to stay focused on the tasks. After finishing each task, I review my todo list and add new tasks which I think need to be done and change or delete existing tasks. Looking at the list I redefined the next most important task which would enable me to show my work to the public.</p>
]]></content>
  </entry>
  
</feed>
